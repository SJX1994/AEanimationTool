//VertexNormalBatchV2 \n     global proc VertexNormalSort(){ \n         if(`window -query -exists adia_myVertexNormalSort_Window`) \n         deleteUI adia_myVertexNormalSort_Window; \n         string $s = \"Adia_vertexNormalBatch\"; \n         window -title $s -menuBar true -maximizeButton false -minimizeButton true adia_myVertexNormalSort_Window; \n         columnLayout -adjustableColumn true; \n             text -label \"Refer the manual to use\" -en off; \n             radioButtonGrp -label \"Mode\" -numberOfRadioButtons 3 \n             -labelArray3 \"Hardening\" \"Copy\" \"Paste\" -sl 1 \n             adia_Select; \n             button -height 23 -width 23 -backgroundColor 255 241 155 -label \"Run\" \n             -command \"Do\"; \n             text -label \" \" -en off; \n         window -edit -widthHeight 600 100 adia_myVertexNormalSort_Window; \n         showWindow adia_myVertexNormalSort_Window; \n     } \n     global string $element_G[]={}; \n     global string $vertexName_G[]={}; \n     global string $objectName_G[]={}; \n     global float $vertexNormal_G[]={}; \n     proc Do() \n     { \n         init(); \n         int $UISwitch = `radioButtonGrp -q -sl adia_Select`; \n         switch($UISwitch) \n         { \n             case 1: \n                 hardening(); \n             break; \n             case 2: \n                 copy(); \n             break; \n             case 3: \n                 paste(); \n             break; \n             default: \n                 print(\"Not In UI\"); \n             break; \n         } \n     } \n     proc hardening() \n     { \n         global string $element_G[]; \n         global string $vertexName_G[]; \n         global string $objectName_G[]; \n         print(\"Harden Run\"+\"\\n\"); \n         string $vtxlist[] = `polyListComponentConversion -ff -tv $element_G`; \n         $vtxlist = `filterExpand -sm 31 -ex true $vtxlist`; \n         for($vtx in $vtxlist) \n         { \n             string $faceList[] = `polyListComponentConversion -fv -tf $vtx`; \n             $faceList =`filterExpand -sm 34 -ex true $faceList`; \n             string $faceList2[] = stringArrayRemove($element_G,$faceList); \n             float $avNormal[] = {0,0,0}; \n             int $i = 0; \n             if(size($faceList2)==0) \n             { \n                 $faceList2 = $faceList; \n             } \n             for($ff in $faceList2) \n             { \n                 string $nrm[] = `polyInfo -faceNormals $ff`; \n                 string $tkBuf[]; \n                 float $tNml[] = {0,0,0}; \n                 tokenize $nrm[0] \" \" $tkBuf; \n                 $tNml[0]+=((float)($tkBuf[2])); \n                 $tNml[1]+=((float)($tkBuf[3])); \n                 $tNml[2]+=((float)($tkBuf[4])); \n                 $avNormal[0] += $tNml[0]; \n                 $avNormal[1] += $tNml[1]; \n                 $avNormal[2] += $tNml[2]; \n                 $i++; \n             } \n             if($i) \n             { \n                 $avNormal[0] = $avNormal[0]/$i; \n                 $avNormal[1] = $avNormal[1]/$i; \n                 $avNormal[2] = $avNormal[2]/$i; \n                 normalize($avNormal); \n                 polyNormalPerVertex -xyz $avNormal[0] $avNormal[1] $avNormal[2] $vtx; \n             } \n         } \n         string $shorterList[] = stringArrayRemoveDuplicates($vertexName_G); \n         string $diff[] = stringArrayRemoveExact($shorterList,$vertexName_G); \n         select -cl; \n         if(size($diff)>0) \n         { \n             for($each in $diff) \n             { \n                 string $check[]={}; \n                 tokenize $each \"vtx[\" $check; \n                 if($check[1]!=\"\\n\"+\"]\") \n                 { \n                     if(catch (`select -tgl $each`)) \n                     { \n                     } \n                     else \n                     { \n                         select -cl; \n                         select -tgl $each ; \n                         polyAverageNormal -prenormalize 1 -allowZeroNormal 0 -postnormalize 0 -distance 0.1 -replaceNormalXYZ 1 0 0 ; \n                         select -cl; \n                     } \n                 } \n             } \n             if(catch(`select -r $objectName_G[0]`)) \n             { \n             }else{select -r $objectName_G[0];} \n             for($ele in $element_G) \n             { \n                 if(catch(`select -tgl $ele`)) \n                 { \n                     print(\"erro\"); \n                 } \n                 else{ \n                     select -add $ele; \n                 } \n             } \n         } \n          \n         pause -sec 1; \n         freed(\"Successfully hardening normal information!\"); \n     } \n     proc copy() \n     { \n         \n         global float $vertexNormal_G[]; \n         print(\"Copy Run\"+\"\\n\"); \n         string $selectList[]; \n         $selectList = `ls -selection -flatten`; \n         $elementVertex = `filterExpand -expand on -selectionMask 31 -selectionMask 70 $selectList`; \n         $elementFace = `filterExpand -expand on -selectionMask 34 $selectList`; \n         if(size($elementVertex)>0) \n         { \n             $vertexNormal_G = `polyNormalPerVertex -q -xyz $elementVertex[0]`; \n             print(\"Copy Value:\"+\"x:\"+ $vertexNormal_G[0]  +\"__y:\"+$vertexNormal_G[1]  +\"__z:\"+$vertexNormal_G[2]); \n         } \n         else if(size($elementFace)>0) \n         { \n             string $faceNormal[] = `polyInfo -fn $elementFace[0]`; \n             string $tkBuf[]; \n 		    float $tNml[]={0,0,0}; \n 		    tokenize $faceNormal[0] \" \" $tkBuf; \n 		    $tNml[0]+=((float)($tkBuf[2])); \n 		    $tNml[1]+=((float)($tkBuf[3])); \n 		    $tNml[2]+=((float)($tkBuf[4])); \n             string $aObjName[] = stringToStringArray( $elementFace[0], \".\"); \n             matrix $mNrm[1][4] = adia_ObjToWorldSpace( \n 		 	adia_CreateVecMatrix($tNml[0],$tNml[1],$tNml[2]) \n 			,$aObjName[0]); \n             float $fVec3[3] = <<$mNrm[0][0], $mNrm[0][1], $mNrm[0][2]>>; \n 		    normalize($fVec3); \n             $vertexNormal_G[0]=$fVec3[0]; \n             $vertexNormal_G[1]=$fVec3[1]; \n             $vertexNormal_G[2]=$fVec3[2]; \n             print(\"Copy Value:\"+\"x:\"+ $vertexNormal_G[0]  +\"__y:\"+$vertexNormal_G[1]  +\"__z:\"+$vertexNormal_G[2]); \n         } \n         freed(\"Successfully copy normal information!\"); \n     } \n     proc paste() \n     { \n          \n         global float $vertexNormal_G[]; \n         print(\"Paste Run\"+\"\\n\"); \n         string $selectList[]; \n         $selectList = `ls -selection -flatten`; \n         $elementVertex = `filterExpand -expand on -selectionMask 31 -selectionMask 70 $selectList`; \n         $elementFace = `filterExpand -expand on -selectionMask 34 $selectList`; \n         if(size($elementVertex)>0) \n         { \n             for($i=0;$i<size($elementVertex);$i++) \n             { \n                 polyNormalPerVertex -xyz $vertexNormal_G[0] $vertexNormal_G[1] $vertexNormal_G[2] $elementVertex[$i]; \n             } \n         } \n         if(size($elementFace)>0) \n         { \n 		    string $sVtxF_c[] = adia_classifyWithObj(`polyListComponentConversion   -toVertexFace $elementFace`); \n 		    int $i = size($sVtxF_c) / 2; \n 		    for($n=0; $n<$i; $n++){ \n 		    	matrix $mNrm[1][4] = adia_WorldToObjSpace(adia_CreateVecMatrix($vertexNormal_G [0],$vertexNormal_G[1],$vertexNormal_G[2]),$sVtxF_c[$n*2]); \n 		    	float $fVec3[3] = <<$mNrm[0][0], $mNrm[0][1], $mNrm[0][2]>>; \n 		    	normalize($fVec3); \n 		    	string $sStr[]; \n 		    	tokenizeList($sVtxF_c[$n*2 + 1],$sStr); \n 		    	select $sStr; \n 		    	polyNormalPerVertex -xyz $fVec3[0] $fVec3[1] $fVec3[2]; \n 		    }	 \n         } \n        \n         freed(\"Successfully pasted normal information!\"); \n     } \n     //tool \n     proc init() \n     { \n         global string $element_G[]; \n         global string  $vertexName_G[]; \n         global string $objectName_G[]; \n         string $selectList[]; \n         $selectList = `ls -selection -flatten`; \n         string $element[]; \n         $element = `filterExpand -expand on -selectionMask 34 $selectList`; \n         for($ele in $element) \n         { \n             $element_G[size($element_G)] = $ele; \n         } \n         if(size($element)>0) \n         { \n             print(\"Executing...\"); \n             for($i = 0 ; $i < size($element); $i++) \n             { \n                 string $objectName[] = stringToStringArray($element[$i], \".\"); \n                 $objectName_G[0] = $objectName[0]; \n                 string $sFaceVertexNormal[]=`polyInfo -faceToVertex $element[$i]`;  \n                 string $vertex[] = stringToStringArray($sFaceVertexNormal[0], \" \"); \n                 string $face[] = stringToStringArray($vertex[1],\":\"); \n                 string $pointPosName1 = $objectName[0]+\".vtx[\"+ $vertex[2] +\"]\"; \n                 string $pointPosName2 = $objectName[0]+\".vtx[\"+ $vertex[3] +\"]\"; \n                 string $pointPosName3 = $objectName[0]+\".vtx[\"+ $vertex[4] +\"]\"; \n                 string $pointPosName4 = $objectName[0]+\".vtx[\"+ $vertex[5] +\"]\"; \n                 $vertexName_G[size($vertexName_G)] = $pointPosName1; \n                 $vertexName_G[size($vertexName_G)] = $pointPosName2; \n                 $vertexName_G[size($vertexName_G)] = $pointPosName3; \n                 $vertexName_G[size($vertexName_G)] = $pointPosName4; \n             } \n         } \n     } \n     proc freed(string $printStr) \n     { \n         global string $element_G[]; \n         global string $vertexName_G[]; \n         global string $objectName_G[]; \n         print($printStr); \n         clear $element_G; \n         clear $vertexName_G; \n         clear $objectName_G; \n     } \n     global proc matrix adia_ObjToWorldSpace(matrix $mIn_Mtx,string $sObj) \n     { \n 	    matrix $mMtx[4][4] = adia_GetObjInvMatrix($sObj); \n 	    matrix $mRes_Mtx[1][4]=$mIn_Mtx*$mMtx; \n 	    return($mRes_Mtx);   \n     } \n     global proc matrix adia_CreateVecMatrix(float $x, float$y, float$z) \n     { \n 	    matrix $mRes_Mtx[1][4]=<<$x,$y,$z,0>>; \n 	    return($mRes_Mtx); \n     } \n     global proc matrix adia_GetObjInvMatrix(string $sObj) \n     { \n     	float $fMat[] = `getAttr ($sObj+\".inverseMatrix\")`; \n     	matrix $mMat[4][4]=<< \n     	$fMat[0],$fMat[4],$fMat[8],$fMat[12]; \n     	$fMat[1],$fMat[5],$fMat[9],$fMat[13]; \n     	$fMat[2],$fMat[6],$fMat[10],$fMat[14]; \n     	$fMat[3],$fMat[7],$fMat[11],$fMat[15]>>; \n     	return($mMat); \n     } \n     global proc string[] adia_classifyWithObj(string $slist[]) \n     { \n     	string $Res[] ; \n     	string $sArr[] = sort($slist); \n     	string $sObjName = \"\"; \n     	string $sCrntObjName[]; \n     	int $i=-1; \n     	string $sNameArray[]; \n     	if(size($sArr)){ \n     		for($sElm in $sArr){ \n     			$sNameArray = stringToStringArray($sElm, \".\"); \n     			if($sNameArray[0] != $sObjName){ \n     				$i++; \n     				$sObjName = $sNameArray[0]; \n     				$Res[$i*2]= $sNameArray[0]; \n     				$Res[$i*2+1]= $sElm; \n     			}else{ \n     				$Res[$i*2+1] = $Res[$i*2+1] + \" \" + $sElm; \n     			} \n     		} \n     	} \n     	return($Res); \n     } \n     global proc matrix adia_WorldToObjSpace(matrix $mIn_Mtx,string $sObj) \n     { \n     	matrix $mMtx[4][4] = adia_GetObjMatrix($sObj); \n     	matrix $mRes_Mtx[1][4]=$mIn_Mtx*$mMtx; \n     	return($mRes_Mtx); \n     } \n     global proc matrix adia_GetObjMatrix(string $sObj) \n     { \n     	 \n     	float $fMat[] = `getAttr ($sObj+\".matrix\")`; \n     	matrix $mMat[4][4]=<< \n     	$fMat[0],$fMat[4],$fMat[8],$fMat[12]; \n     	$fMat[1],$fMat[5],$fMat[9],$fMat[13]; \n     	$fMat[2],$fMat[6],$fMat[10],$fMat[14]; \n     	$fMat[3],$fMat[7],$fMat[11],$fMat[15]>>; \n  \n     	return($mMat); \n     } \n     VertexNormalSort();