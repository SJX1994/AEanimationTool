# 现代游戏通讯：
## 基础通讯概念：
- TCP
  - 慢且准
- UDP
  - 快且疏
- Snapshot
  - 它在游戏中的不同客户端之间传输游戏对象的数据，以确保所有客户端都具有一致的游戏状态。
  - 在多人游戏中，每个客户端都有自己的本地游戏状态。
  - 为了使所有客户端都知道其他客户端的状态，需要进行网络同步。
  - 网络快照通常包含游戏对象的位置、旋转、速度、动画状态等关键信息。这些快照会周期性地发送给其他客户端，以确保各个客户端都能够准确地呈现游戏状态。
## 通讯媒介：
- Socket
  - 通讯的基础
  - 计算机用于实现网络通信的编程接口
  - 具体过程：
    1. 创建Socket对象：游戏客户端和服务器端都需要创建一个Socket对象。
    2. 绑定地址和端口：在服务器端，需要将Socket对象绑定到一个特定的IP地址和端口号上，以便客户端可以连接到它。
    3. 建立连接：服务器端需要监听并接受客户端的连接请求，而客户端则需要主动连接到服务器端。
    4. 数据传输：一旦连接建立，客户端和服务器端就可以使用Socket对象发送和接收数据。
    5. 关闭连接：在通信结束后，需要关闭Socket连接，释放资源。        
## 常用通讯架构：
- C/S：Client-Server
  - 一般流程：
    1. 客户端发起连接：
       - 客户端应用程序通过网络连接到服务器。在网络游戏中，这通常是通过建立TCP或UDP Socket连接实现的。
    2. 服务器监听连接：
       - 服务器端会监听传入的连接请求，并接受客户端的连接。
    3. 客户端发送请求：
       - 一旦连接建立，客户端可以向服务器发送请求，请求特定的服务或操作。
    4. 服务器处理请求：
       - 服务器端会处理客户端的请求，并返回响应。
       - 这可能涉及到处理游戏逻辑、读取和写入数据库、计算等操作。
    5. 服务器返回响应：
       - 服务器会根据请求的处理结果生成响应数据，并将其发送回客户端。
    6. 客户端接收响应：
       - 客户端接收来自服务器的响应数据，并对其进行处理，例如更新游戏界面、显示信息等。
    7. 客户端关闭连接：
       - 一旦通信结束，客户端会关闭连接，释放资源。
  - 优势：
    - 分布式处理：
      - 服务器可以专门处理复杂的逻辑和大量的数据，而客户端只需要处理用户界面和用户交互等简单操作。
    - 集中管理：
      - 服务器可以集中管理游戏状态和数据，确保数据的一致性和安全性。
    - 可扩展性：
      - 通过增加服务器的数量和负载均衡技术，可以支持大量的客户端连接。
  - 挑战：
    - 服务器负载：
      - 服务器需要处理并响应大量的客户端请求，需要具备足够的处理能力和带宽。
    - 网络延迟：
      - 由于客户端和服务器之间的数据传输需要经过网络，网络延迟可能会对游戏性能和响应速度产生影响。
    - 单点故障：
      - 如果服务器发生故障，可能会影响到所有客户端的连接和服务。
- B/S：Host
  - 特点：
    - 分布式：
      - 玩家之间直接通信，减少了对集中服务器的依赖。
    - 实时性：
      - 由于玩家之间直接通信，数据传输和响应时间通常较短，可以实现较好的实时性。
    - 可伸缩性：
      - 由于不需要集中服务器处理所有玩家的请求，可以灵活添加或移除游戏主机。
      
  - 挑战：
    - 可靠性：
      - 由于主机扮演着服务器和客户端的双重角色，如果主机离线或掉线，会导致其他玩家无法继续游戏。
    - 安全性：
      - 主机需要处理和传输其他玩家的数据，需要确保数据的安全性和防范可能的作弊行为。
    - 带宽和性能要求：
      - 由于主机需要同时处理多个玩家的数据传输，可能对主机的带宽和性能提出较高的要求。   
- P2P：Peer To Peer
  - 概念：
    - 每个节点既可以充当客户端，也可以充当服务器，承担数据的请求和响应角色。
    - 每个节点都可以发起连接并与其他节点进行直接通信，而不需要经过中心服务器进行中转。
  - 特点：
    - 分散式：
      - P2P网络中的节点是平等的，没有中心化的控制点。
      - 每个节点都可以与其他节点进行直接通信，没有单点故障。
    - 资源共享：
      - 每个节点可以共享自己的资源，如带宽、存储空间、计算能力等。
      - 这使得P2P架构在文件共享、内容分发等方面具有优势。
    - 扩展性：
      - P2P架构可以很好地扩展到大规模网络，
      - 因为每个节点的加入或退出不会对整个网络造成太大影响。
  - 应用：
    - 文件共享：
      - P2P网络允许用户直接从其他用户下载和共享文件，而不需要依赖中心服务器。
      - BitTorrent是著名的P2P文件共享协议之一。
    - 实时通信：
      - P2P架构可以支持实时的点对点通信，例如音视频通话、即时消息等。
      - Skype和BitTorrent Live就是采用了P2P技术来实现实时通信的应用。
    - 区块链：
      - 区块链可以看作是一种分布式的P2P数据库，其中每个节点都保存了完整的账本。
      - 比特币和以太坊等加密货币就是基于P2P架构构建的区块链系统。
  - 挑战：
    - 网络配置问题：
      - 由于P2P网络依赖于节点之间的直接连接，可能涉及网络地址转换（NAT）和防火墙等配置问题，使得节点之间难以直接通信。
    - 可靠性：
      - 由于节点是平等和分散的，无法保证节点的稳定性和可靠性，特别是在节点频繁加入和退出的情况下。
    - 安全性：
      - 在P2P架构中，节点之间直接通信，需要采取安全措施来防止篡改、伪造和攻击等问题。
- Hybrid：Client-Server + Peer To Peer 的混合架构
  - 优势：
    - 中心服务器的优势：
      - 中心化服务器能够提供稳定的连接、协调游戏逻辑和处理核心功能，例如匹配制度、用户认证、排行榜、保存游戏进度等。
      - 服务器可以负责维护整个游戏的状态，以确保一致性和公平性。

    - P2P架构的优势：
      - P2P架构可以减轻服务器的负载，通过玩家之间的直接通信来改善游戏性能和延迟。
      - P2P架构可以提供更快的数据传输速度和更实时的游戏体验。
      - 此外，P2P架构还可以增加系统的可扩展性，因为每个节点都可以成为游戏的一部分，承担一部分负载。

    - 数据同步和冲突解决：
      - Hybrid架构需要解决中心化服务器与P2P节点之间的数据同步和冲突解决。
      - 服务器负责维护全局的游戏状态，而P2P节点负责存储和传输局部的游戏状态。
      - 同步机制和冲突解决算法需要确保玩家之间的状态一致，以避免游戏中的不一致和冲突情况。

    - NAT穿越和连接管理：
      - 由于P2P架构的特性，可能涉及到NAT穿越和连接管理的问题。
      - 服务器可以提供辅助功能来解决这些问题，协助P2P节点建立直接的连接和穿越NAT。
      - 以确保节点之间的通信能够顺利进行。

# Unity框架
## Mirror:
- Ref：
  - 基础
    - https://www.jianshu.com/p/c44638cd59f0
    - https://youtu.be/8tKFF0RP9Jw?si=OZ-VSB0JlnSz3JNF
  - 自定义
    - https://mirror-networking.gitbook.io/docs/manual/guides/gameobjects/custom-character-spawning
  - 可传输的数据类型
    - https://mirror-networking.gitbook.io/docs/guides/data-types
    - 字典：
      - https://mirror-networking.gitbook.io/docs/manual/guides/synchronization/syncdictionary
      - https://fish-networking.gitbook.io/docs/manual/guides/synchronizing/syncdictionary
- NetworkBehaviour 网络行为和功能：
  - 概念：
    - 用于实现网络行为和功能的组件。
  - 功能：
    - 网络消息：
      - 可以通过装饰器 [Command]、[ClientRpc]、[TargetRpc] 等自定义属性和方法来定义网络消息。
    - 生命周期：
      - 这些方法在客户端和服务器上的相应时间点调用，以便执行网络行为逻辑。
    - 同步变量：
      - NetworkBehaviour 支持使用 SyncVar 属性标记变量，以实现在客户端和服务器之间同步变量的功能。
      - 当 SyncVar 变量的值在服务器上发生更改时，该变化将被自动同步到所有客户端。
    - 消息过滤：
      - NetworkBehaviour 具有 Target 概念，通过带有 NetworkConnection 方法，可以将消息定向发送给特定客户端。
    - 权限控制：
      - NetworkBehaviour 支持在方法上使用 [Server]、[Client] 等属性，以限制哪些实体可以调用该方法。这有助于确保只有授权的客户端或服务器可以执行特定的网络操作。
  - NetworkTransformBase：
    - 被继承：
      - NetworkTransformUnreliable：
        - 简介：
          - 是一种用于网络同步游戏对象位置和旋转信息的组件。
          - 在网络条件较差或丢包的情况下，可能会导致数据丢失或不同步。
      - NetworkTransformReliable：
        - 简介：
          - 可靠地同步游戏对象位置和旋转信息的组件。
          - 确保数据的完整性和准确性。 
    - 参数：
      - clientAuthority（过时 被syncDirection替代）：设置为true具有客户端权限，当一个网络对象具有客户端权限时，客户端可以在局部控制该对象的位置和旋转信息，而服务器只处理其他客户端发送的位置和旋转同步信息。
      - interpolate：提供更流畅的观感。但会造成额外的本地计算量。
      - coordinateSpace：与世界坐标系的位置和旋转一致 或者 父对象或自身的初始位置和旋转进行同步。
      - sendIntervalMultiplier：网络对象同步频率的一个乘数因子。
        - 设置为2，那么位置信息的发送间隔将乘以2，从而减少发送频率到原来的一半。这样可以减少带宽消耗和网络负载，但也会导致位置信息的更新速度变慢。
      - timelineOffset：Mirror会使用时间偏移来处理网络对象的位置同步。具体来说，Mirror会根据网络延迟和插值算法来预测其他客户端接收到位置更新的时间，并将网络对象的位置信息进行线性插值以平滑显示。使用时间偏移可以帮助消除网络延迟造成的位置信息的跳跃和抖动，提供更平滑的移动效果。
      - 
  - OnStartServer()
    - 通过将特定的消息发送到服务器，以触发服务器上的对应代码。
    - 由NetworkServerHandler的组件处理
- NetworkManager 管理器：
  - 简介：
    - 用于管理网络连接和游戏会话的创建和销毁。
  - 功能：
    - 网络连接管理：
      - NetworkManager 用于管理客户端和服务器之间的网络连接。
      - 它可通过协调连接、断开连接和连接状态等操作，来确保客户端与服务器之间的网络连接正常建立和维护。
    - 游戏会话管理：
      - NetworkManager 负责管理游戏会话的创建和销毁。
      - 它能够启动服务器端实例并监听网络连接请求，并为每个客户端分配唯一的连接实例。
    - 网络配置：
      - NetworkManager 提供了一些配置选项，用于设置网络参数和协议。
      - 例如，可以设置服务器的 IP 地址和端口号，选择使用哪种网络传输方式（如 TCP 或 UDP），以及是否使用自动场景加载等。
    - 网络事件处理：
      - NetworkManager 提供了一些事件回调，用于处理网络连接状态的变化和网络事件的发生。
      - 例如，可以响应客户端连接的建立和断开、服务器启动和关闭等事件。
    - 网络场景管理：
      - NetworkManager 允许开发人员定义网络场景，并控制在不同场景之间的切换和同步。
      - 它提供了一些方法和属性，用于加载、切换和同步场景，并确保所有客户端上的场景保持一致。
  - 方法：
    - 虚方法 OnServerAddPlayer (服务器)
      - OnServerAddPlayer是NetworkManager中的一个回调方法。
      - 用于当新的玩家连接到服务器时执行特定的操作。
      - 该方法在服务器上被调用，而不是在客户端上。
    - 虚方法 OnServerDisconnect
      - OnServerDisconnect是Mirror网络库中NetworkManager的另一个回调方法。
      - 用于在服务器上处理玩家断开连接的事件。
  - 参数：
    - runInBackground：在游戏失去焦点时是否继续运行网络连接和更新。
    - sendRate：值为30，这意味着每秒向服务器发送30次网络消息。你可以根据你的游戏需求调整这个值。如果你想要更实时的同步效果，可以增加sendRate的值
    - offlineScene（离线场景）：这是在本地模式下（即没有网络连接）加载的场景。当NetworkManager处于离线模式时，它会加载offlineScene所指定的场景。
    - onlineScene（在线场景）：这是在联网模式下（即有网络连接）加载的场景。当NetworkManager建立网络连接后，它会加载onlineScene所指定的场景。
    - transport：用于指定在网络通信中使用的传输协议。
      - KcpTransport：Kuai Control Protocol 自定义传输模块，用于网络游戏的数据传输。它基于开源库KCP（KCP - A Fast and Reliable ARQ Protocol）作者 韦易笑，提供了一种快速和可靠的数据传输方案。
      - https://mirror-networking.gitbook.io/docs/manual/transports/kcp-transport
    - networkAddress：指定网络连接的目标地址（IP地址或域名）。networkAddress的值应该是一个字符串，表示要连接的服务器的地址。这可以是一个IPv4或IPv6地址，也可以是一个域名（例如，game.example.com）。
    - disconnectInactiveConnections:用于指定在网络连接处于非活动状态时是否断开连接。
    - disconnectInactiveTimeout:表示网络连接在多长时间没有任何活动和数据传输后会被自动断开。以秒为单位。
    - authenticator：是NetworkManager的一个属性，它允许你指定一个实现了NetworkAuthenticator抽象类的自定义身份验证器。这个身份验证器可以用来验证客户端和服务器之间的身份，并确保只有受信任的用户可以建立连接和进行通信。
    - playerPrefab：当有新的客户端连接到服务器时，NetworkManager将使用playerPrefab创建一个新的玩家对象，并将其分配给该连接。
    - autoCreatePlayer：是一个用于指定网络连接建立后是否自动创建玩家对象的属性。
    - playerSpawnMethod：
      - RoundRobin：表示将玩家对象按照循环规则分配给连接。
      - Random：表示将玩家对象随机分配给连接。
    - snapshotSettings:
      - 用于指定网络快照的配置。
      - bufferTimeMultiplier:
        - 调整网络快照（Snapshot）缓冲时间的倍数的属性。
        - 缓冲时间是指在发送方发送快照后，在接收方处理和应用完整个快照之前的时间间隔。缓冲时间的设置可以影响整体的网络同步表现和延迟。
      - snapshotSettings:缓冲限制是指在接收方处理和应用快照时允许保留的最大快照数量。当快照数量超过bufferLimit时，最旧的快照将被丢弃。
      - catchupNegativeThreshold: 允许同步系统从正常速度快速调整到更快的速度，以便追赶上当时的网络状态。
      - catchupPositiveThreshold: 允许同步系统从较慢的速度快速调整到更快的速度，以追赶上当时的网络状态。
      - catchupSpeed: 同步系统在每个网络更新周期中调整的比例。默认值为0.1，表示同步系统在每个网络更新周期中调整为当前网络状态的10%。
      - slowdownSpeed: 同步系统在网络延迟变高时，降低同步速度的比例。默认值为0.01，表示同步系统在每个网络更新周期中将当前速度降低1%。
      - driftEmaDuration: 
        - 属性设置为2秒，这意味着同步系统将使用过去2秒内的延迟测量值来计算漂移指数移动平均。
        - 同步系统用于计算漂移指数移动平均的时间跨度。漂移指数是用来估计网络延迟和带宽的指标，可以帮助同步系统更准确地进行同步。
      - dynamicAdjustment: 控制同步系统在网络状况发生变化时动态调整发送快照的频率和相关参数。它可以根据网络延迟和带宽等指标来自动调整同步系统的性能以获得最佳的同步效果。
      - dynamicAdjustmentTolerance: 配置同步系统动态调整的容忍度。设置为0.05，这意味着同步系统在执行动态调整时，每次调整的幅度不会超过0.05。这样可以确保同步系统的调整是平滑的，避免因过度调整而导致不稳定的同步效果。
      - deliveryTimeEmaDuration： 和 driftEmaDuration 差不多。
        - 属性设置为2秒，这意味着发送系统将使用过去2秒内的延迟测量值来计算漂移指数移动平均。
        - 发送系统用于平均的时间跨度。
      - connectionQualityInterval：设置为1秒，这意味着同步系统将每隔1秒进行一次连接质量检测。
      - 
- NetworkIdentity 身份ID：
  - 简介：
    - 标识具有网络功能的游戏对象。使得游戏对象能够在多台计算机之间进行网络同步
    - 唯一标识、持久化、网络同步、
    - 服务器授权模式下，服务器负责控制游戏对象的状态，而客户端只能向服务器发送请求。
    - 在客户端授权模式下，客户端可以控制自己的游戏对象状态，并将相应的更改通知服务器和其他客户端。
  - 参数：
    - assetId
      - 网络中的客户端和服务器通过这个assetId来唯一标识NetworkIdentity
    - 
- NetworkServer 处理网络连接和同步游戏状态的中心服务：
  - 连接管理：
    - NetworkServer负责管理网络连接。当一个客户端连接到服务器时，NetworkServer会分配一个唯一的连接ID，并将客户端添加到连接列表中。它还会跟踪客户端是否已断开连接，并在客户端断开连接时进行清理。
  - 对象生成与同步：
    - NetworkServer负责生成和同步网络对象。当服务器上生成一个网络对象时，它会在服务器和所有已连接的客户端上生成相同的对象。NetworkServer会跟踪生成的网络对象，并向所有客户端发送同步消息，以确保它们在各个客户端上保持同步。
    - 消息传递：当一个客户端发送消息到服务器时，NetworkServer会接收并处理这些消息。它通过消息的类型和目标对象来决定如何处理消息。例如，如果消息是用于生成网络对象的请求，NetworkServer会在服务器上生成对象，并通知所有客户端同步生成的结果。如果消息是更新对象属性的请求，NetworkServer会更新服务器上的对象状态，并广播该状态给所有客户端。
- NetworkManagerHUD 网络管理器的HUD：
  - 可视化网络管理器的HUD (Heads-Up Display)  
  - 依赖 NetworkManager
- Attribute 装饰器：
    - 被装饰的方法将被注册到服务器的回调列表中，以便在适当的时机被调用。
    - `[Server]`：
      - 只在服务器上运行
      - 阻止客户端运行此方法。
      - 如果客户端尝试执行此方法，则会打印警告。
    - `[ServerCallback]`：
      - 在服务器上调用
      - 不会引发任何警告。
    - `[Client]`：
      - 只在客户端上运行
      - 阻止服务器运行此方法。
    - `[ClientRpc]`：
      - 在服务器上调用，然后在所有客户端上调用
      - 服务器使用远程过程调用（RPC）在客户端上运行此功能。
    -  `[ClientCallback]`：
       -  在客户端上调用
       -  不会引发任何警告。
    - `[TargetRpc]`：
      - 在服务器上调用，然后在特定客户端上调用
      - 服务器使用远程过程调用（RPC）在特定客户端上运行此功能。
    - `[SyncVar]`：
      - 在服务器上更改，然后在所有客户端上同步.
      - SyncVars 用于自动将变量从服务器同步到所有客户端。
      - 值必须在服务器上更改，而不是由客户端直接更改。
    - `[SyncVar(hook = "OnChangeHealth")]`：
      - 在服务器上更改，然后在所有客户端上同步，并调用OnChangeHealth方法
      - Hook 参数允许您定义当客户端从服务器获取更新时要调用的客户端方法。
    - `[Command]`：?
      - 从客户端调用此函数以在服务器上运行此函数。
    - `[Scene]`:
      - 将字符串属性转换为检查器中的场景属性
- NetworkConnection 区分玩家状态：
    - 流程：
      1. 当客户端连接到服务器时，服务器会为每个连接的客户端创建一个玩家实例，并为其分配一个唯一的标识符（NetworkConnection）。
      2. 服务器将与每个客户端建立的连接与相应的 NetworkBehaviour 实例进行关联。
      3. 每个与服务器连接的客户端都会在本地创建一个实例。
      4. 当服务器向客户端发送网络消息时，会将目标玩家的标识符附加在消息中，以便客户端知道如何处理该消息。
      5. 当客户端接收到网络消息时，Mirror 框架会检查消息中附加的玩家标识符，并确定该消息是针对本地玩家还是其他玩家。
    - NetworkConnection：
      - 概念：
        - NetworkConnection 是一个用于管理网络连接的抽象概念，而 NetworkBehaviour 是 NetworkConnection 上的组件，用于实现网络行为。
        - NetworkConnection 表示客户端和服务器之间的连接。它在客户端和服务器之间传递网络消息，并管理连接状态和同步数据。每个客户端与服务器之间的连接都会有一个唯一的 NetworkConnection 实例。
        - NetworkConnectionToClient 和 NetworkConnectionToServer 是 NetworkConnection 的子类，用于表示客户端和服务器之间的连接。
      - 具体内容：
        - LocalConnectionId:
          - 标识连接：
            - 通过 LocalConnectionId，可以在服务器和客户端之间准确地识别特定的连接。这对于在服务器上管理多个客户端连接非常有用，可以根据 LocalConnectionId 来追踪和管理每个连接的状态和数据。
          - LocalConnectionId 只在本地有效，并不保证在不同的客户端或服务器之间具有相同的值，因此不能用于直接比较连接之间的关系。
        - connectionId
          - 由传输分配，此 ID 对于服务器上的每个连接都是唯一的。
          - 客户不知道自己的 ID，也不知道其他客户的 ID。
# 案例：
## Mirror
### Pong:        
## Boss Room ：
- 展示类似多人游戏中经常出现的典型网络代码模式。
