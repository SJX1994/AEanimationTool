文档规则：
    注释：
        (这是注释)
    省略：
        ...
    包含：
        <
    值：
        >
    代码：
        <(代码)>

设计模式：
    单例模式：

        思路：
            限制了实例的个数
        好处：
            节省内存

    中介者模式：

        中介者对象，该对象封装了系统中对象间的交互方式，例如 MVVM
    
    迭代器：
        是确使用户可在容器对象（container，例如链表或数组）上遍访的对象
        例如：
            python中的 in 关键字的用法

算法：
    折半搜索
    汉诺塔算法
    并行计算
    离线算法
    数据结构
        链表
    大O算法:
    贪心算法
    动态规划
    路由算法
    P2P:
        分布式散列表
    多媒体传输
    *任务调度
    线程切换
    内存管理
    银行家算法
    硬盘读取的电梯算法
    TCP
        流量限制
        堵塞控制
    加密算法
    共有密码
    隐蔽通道
    非对称加密
    不重复密码
    哈夫曼树：
        目的：通过二进制来传输信息
        方法：通过 使用频率 生成一张表，通过表中的权重生成 树。
        算法关键：
            传输的信息永远在末端，树只有两个分叉（小 0 大 1）
        伪代码：
            权重(3,2,1,4)
            生成树：
                -5: ( 1 + 2 + 3 + 4 )      
                -4: (1 + 2 + 3), 4        4 = 1
                -3: (1 + 2 + 3)
                -2: (1+2) , 3             3 = 01
                -1：(1+2)    
                0 ：1 , 2                 1 = 000 , 2 = 001
            最终传输：
                二进制：
                    01 001 000 1
                表:
                    10
                  6    "4"
                3  "3"
            "1"   "2"

        传输法：
            获取远端使用频率表
            生成深度树(哈夫曼树)
            传输：二进制码，对应的 远端哈夫曼树
        加密法：
            本地生成频率表
            生成深度树(哈夫曼树)
            传输：二进制码，对应的 本地哈夫曼树


数据结构：
    数据的顺序和位置
    链表：
        添加删除快
        访问费时
        每个数据的指针指向下一个数据内存地址
        无需连续

    数组
    栈
    队列
    哈希表
    堆
    二叉查找树
    斐波那契堆：
        涉及算法：
            链表，普通堆，Dijkstra算法
        涉及理论：
            均摊复杂度分析
                势函数
            大O表示法
    复杂度：
        大O时间复杂度：
            T(n) = O(f(n))
                n表示数据规模，例如循环n次为n个 单位时间
                f(n)表示代码执行的时间复杂度计算公式
                O表示：T(n)最终目标机器的时间 与 f(n)推导的时间复杂度的 比例
            最终得出数据规模的增长趋势
            量级:
                多项式量级:
                    O(1) 常量级
                    
                        所有常数量级
                            int a = 1;
                            xxx.get()
                            xxx.set()
                            xxx.push()
                    O(logn) 对数级

                        是等比数列
                        O(log3):
                            i=1;
                            while (i <= n)  {
                            i = i * 3;
                            }
                        计算：
                            2^0 2^1 2^2 ... 2^n
                        
                    O(nlogn) 线性对数级
                        for(m = 1; m < n; m++) {
                            i = 1;
                            while(i < n) {
                                i = i * 2;
                            }
                        }

                    O(n) 线性级
                        for(i=1; i<=n; i++) {
                            j = i;
                            j++;
                        }
                        1行会执行 n 次，第2行和第3行会分别执行n次，总的执行时间也就是 3n + 1 次
                        但时间复杂度其实是O(n)

                非多项式量级
                    O(n^n^) 平方级
                        嵌套2层 循环：
                            for(x=1; i <= n; x++){
                                for(i = 1; i <= n; i++) {
                                    j = i;
                                    j++;
                                    }
                            }
                            表示 O(n^2) 3层 就表示 O(n^3)
                    O(n!) 阶乘级

        时间复杂度
           
        空间复杂度
        均摊复杂度

        ref：
            https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&mid=2247487668&idx=1&sn=47d0565d4a0cac127bcf1a64add459f4&source=41#wechat_redirect
软件架构：

    MVVM( MVC的延展 ):
        目标：
            从模型中转换数据对象，以便轻松管理和呈现对象
        案例：
            Kanzi
    MVC:
        目标：
            实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。
        案例:
            unity 可以实现
    MVP（MVC的延展）:
        多了Presenter：
            事件处理模块