文档规则：
    注释：
        (这是注释)
    省略：
        ...
    包含：
        <
    值：
        >
    代码：
        <(代码)>

设计模式：
    单例模式：
        思路：
            限制了实例的个数
        好处：
            节省内存

    中介者模式：
        中介者对象，该对象封装了系统中对象间的交互方式，例如 MVVM
    
    迭代器：
        是确使用户可在容器对象（container，例如链表或数组）上遍访的对象
        例如：
            python中的 in 关键字的用法

算法：
    快速排序：
        // 用 C++ 手动实现快速排序算法，要求时间复杂度尽量稳定，代码风格尽量简洁清晰，可以封装工具函数。Bonus. 把排序函数封装进独立的 class，要求尽量健壮和安全，在各种使用情况下都应有合理行为。
            #include <iostream>
            using namespace std;
            int f_partition(int a[],int,int);
            void f_quickSort(int a[],int,int);

            int main()
            {
            int array[] = {3,1,2,34,43,23};
            int len = sizeof(array)/sizeof(int);
            cout << "原始数组：" << endl;
            for(int i=0; i<len; i++)
            {
                cout<<array[i]<<"  ";
            }
            cout << "" << endl;
            f_quickSort(array,0,len-1);
            cout << "快排后数组：" << endl;
            for(int i=0; i<len; i++)
            {
                cout<<array[i]<<"  ";
            }
            cout << "" << endl;
            return 0;
            }


            void f_quickSort(int l_array[], int l_start , int l_end)
            {
            if(l_start >= l_end) return;
            
            // 分区数组
            int m_p = f_partition(l_array,l_start,l_end);
            // 从左边
            f_quickSort(l_array,l_start,m_p-1);
            // 从右边
            f_quickSort(l_array,m_p+1,l_end);
            }

            int f_partition(int l_array[], int l_start,int l_end)
            {
            int m_pivot = l_array[l_start];
            int m_count = 0;
            for(int i = l_start + 1; i <= l_end; i++ )
            {
                if(l_array[i] <= m_pivot)
                m_count ++;
            }
            // 给数字正确的索引
            int m_pivotIndex = l_start + m_count;
            swap(l_array[m_pivotIndex],l_array[l_start]);
            
            // 整理左右部分
            int i = l_start, j = l_end;
            while(i < m_pivotIndex && j > m_pivotIndex)
            {
                while(l_array[i] <= m_pivot)
                {
                    i++;
                }
                while(l_array[j] > m_pivot)
                {
                    j--;
                }
                if(i < m_pivotIndex && j > m_pivotIndex)
                {
                    swap(l_array[i++],l_array[j--]);
                }
            }
            return m_pivotIndex;
            }
    折半搜索
    汉诺塔算法
    并行计算
    离线算法
    数据结构
        链表
    大O算法:
    贪心算法
    动态规划
    路由算法
    P2P:
        分布式散列表
    多媒体传输
    *任务调度
    线程切换
    内存管理
    银行家算法
    硬盘读取的电梯算法
    TCP
        流量限制
        堵塞控制
    加密算法
    共有密码
    隐蔽通道
    非对称加密
    不重复密码
    哈夫曼树：
        目的：通过二进制来传输信息
        方法：通过 使用频率 生成一张表，通过表中的权重生成 树。
        算法关键：
            传输的信息永远在末端，树只有两个分叉（小 0 大 1）
        伪代码：
            权重(3,2,1,4)
            生成树：
                -5: ( 1 + 2 + 3 + 4 )      
                -4: (1 + 2 + 3), 4        4 = 1
                -3: (1 + 2 + 3)
                -2: (1+2) , 3             3 = 01
                -1：(1+2)    
                0 ：1 , 2                 1 = 000 , 2 = 001
            最终传输：
                二进制：
                    01 001 000 1
                表:
                    10
                  6    "4"
                3  "3"
            "1"   "2"

        传输法：
            获取远端使用频率表
            生成深度树(哈夫曼树)
            传输：二进制码，对应的 远端哈夫曼树
        加密法：
            本地生成频率表
            生成深度树(哈夫曼树)
            传输：二进制码，对应的 本地哈夫曼树
    A*寻路算法：
        A* 是一种知情搜索算法，或最佳优先搜索，这意味着它是根据加权图制定的：从图的特定起始节点开始，它旨在找到到给定目标节点的路径具有最小的 成本（最短距离、最短时间等）。
    最小生成树：
        目的：保证每点都有通路，且是最小路径
        Prim 算法实现：
            一种贪心算法，在每个步骤中，将最短的可能连接从树添加到另一个顶点。
        Kruskal 算法实现：
            创建一个域，所有两点之间距离在域中的值，比较最小的，并联通。
    Bowyer-Watson 算法：
        是任意维数的“Delaunay三角剖分”，该算法还可用于获得点的“Voronoi图”
        “Delaunay三角剖分”：
            一组离散点，两两相连为半径做圆，连接圆内的点
        “Voronoi图”：
            一组离散点，两点的中点做垂线，以垂线划分出区域
        ref：
            https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm

数据结构：
    数据的顺序和位置
    链表：
        添加删除快
        访问费时
        每个数据的指针指向下一个数据内存地址
        无需连续

    数组
    栈
    队列
    哈希表
    堆
    二叉查找树
    斐波那契堆：
        涉及算法：
            链表，普通堆，Dijkstra算法
        涉及理论：
            均摊复杂度分析
                势函数
            大O表示法
    复杂度：
        大O时间复杂度：
            T(n) = O(f(n))
                n表示数据规模，例如循环n次为n个 单位时间
                f(n)表示代码执行的时间复杂度计算公式
                O表示：T(n)最终目标机器的时间 与 f(n)推导的时间复杂度的 比例
            最终得出数据规模的增长趋势
            量级:
                多项式量级:
                    O(1) 常量级
                    
                        所有常数量级
                            int a = 1;
                            xxx.get()
                            xxx.set()
                            xxx.push()
                    O(logn) 对数级

                        是等比数列
                        O(log3):
                            i=1;
                            while (i <= n)  {
                            i = i * 3;
                            }
                        计算：
                            2^0 2^1 2^2 ... 2^n
                        
                    O(nlogn) 线性对数级
                        for(m = 1; m < n; m++) {
                            i = 1;
                            while(i < n) {
                                i = i * 2;
                            }
                        }

                    O(n) 线性级
                        for(i=1; i<=n; i++) {
                            j = i;
                            j++;
                        }
                        1行会执行 n 次，第2行和第3行会分别执行n次，总的执行时间也就是 3n + 1 次
                        但时间复杂度其实是O(n)

                非多项式量级
                    O(n^n^) 平方级
                        嵌套2层 循环：
                            for(x=1; i <= n; x++){
                                for(i = 1; i <= n; i++) {
                                    j = i;
                                    j++;
                                    }
                            }
                            表示 O(n^2) 3层 就表示 O(n^3)
                    O(n!) 阶乘级

        时间复杂度
           
        空间复杂度
        均摊复杂度

        ref：
            https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&mid=2247487668&idx=1&sn=47d0565d4a0cac127bcf1a64add459f4&source=41#wechat_redirect
软件架构：

    MVVM( MVC的延展 ):
        目标：
            从模型中转换数据对象，以便轻松管理和呈现对象
        案例：
            Kanzi
    MVC:
        目标：
            实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。
        案例:
            unity 可以实现
    MVP（MVC的延展）:
        多了Presenter：
            事件处理模块
    UML:
        用例图
            用例拆分
        子系统
        关系：
            关联关系
            泛化关系（继承关系）
            包含关系
            拓展关系
        类图：
            属性图
            方法图
            关系图
            关联关系图
            泛化关系图
            包含关系图
            拓展关系图




使用案例：
    随机地牢生成方案：
        涉及算法：
            Bowyer-Watson 算法 （路径生成）
            最小生成树 Prim 算法 （路径筛选）
            A*寻路算法 （预制体生成）
        ref：
        https://youtu.be/rBY2Dzej03A