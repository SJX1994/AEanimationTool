3D:
      几何着色器：
            以图元（通常是三角形）为单位进行操作
      顶点
            输入项：
                  物体位置(Position)
                  法线位置(Normal)
                  切线位置(Tangent)
                  权重(weight)
                  矩阵索引(matrix indices)
                  贴图坐标(texture coordinates)
                  顶点色(vertex color)
                  融合 位置 法线 切线 (MorphTarget)
            公共项：
                  贴图采样(sampler texture)
                  不透明度(Opacity)
                  世界矩阵(worldMatrix)
                  相机矩阵(cameraMatrix)
                  相机转世界矩阵(worldCameraMatrix)
                  投影到相机矩阵(ProjectionCameraWorldMatrix)
                  投影矩阵(ProjectionMatrix)
                  法线矩阵(NormalMatrix)
                  相机法线矩阵(CameraNormalMatrix)
                  相机位置(CameraPosition)
                  时间(Time)
                  贴图大小(TextureSize)
                  矩阵调色板(matrix Paletter)?
                  相机距离(cameraNearFarPlane)
                  融合权重(MorphWeight)
                  视口坐标(viewPort)v4
                  窗口坐标(window)v2
            传递属性：
                  varying
      片元:
            所有公共项
            传递属性：
                  varying

      后处理：
      缓存：
      抗锯齿：
            图像锐化：
                  https://www.cnblogs.com/shuopython/p/16275887.html
                  https://github.com/BradLarson/GPUImage/blob/master/framework/Source/GPUImageSharpenFilter.m
                  https://segmentfault.com/a/1190000037749983
2D:
      图形绘制：
            在片元中以UV为xy为坐标象限进行绘制

渲染管线：
      大型状态机：
            Blit Render Pass:
                  位块传送渲染通道
                  使用某种特定材质在屏幕上位块传送一个或多个渲染通道或纹理。
            Clear Render Pass:
                  清除当前渲染上下文的部分或全部缓冲。您可以设置 Kanzi 清除颜色、深度和模具缓冲区的值。
            Composition Target Render Pass:
                  将自身及其子渲染通道渲染成合成目标。
            Draw Objects Render Pass:
                  允许您设置摄像机 (Camera) 节点来渲染特定对象源并控制视锥体剔除。
            Draw Objects With Material Render Pass:
            Group Render Pass:
            Lagacy Render Pass (deprecated):
                  一个封装好的渲染管线
            Material Setup Render Pass:
            Pipline State Render Pass:

性能优化：
      遮挡剔除：
            光栅化之前的OverDraw，减少绘制次数。注意半透明物体没有办法进入OverDraw的优化，慎用尤其是半透明的粒子系统，可能会造成性能爆炸。
            相交的几何会发生另一个问题。在这里，透支变得不可预测，因为不能在同一次绘制调用中保证像素渲染顺序。
            对于自相交的几何，还可以以合理的方式将其拆分为不同的几何块。在上一个屏幕截图的情况下，您可以将其完全分成四个平面，因此基于距离的排序将正确地完成其工作（请注意，这个操作将支付更多的Draw Call，以减少OverDraw，这个需要再实际项目中做平衡，看是CPU有余量还是GPU有余量，这里只作为例子介绍减少OverDraw的策略）。
            
            ref：
                  https://thegamedev.guru/unity-gpu-performance/overdraw-optimization/#5-the-unity-overdraw-cheatsheet-for-2020
                  https://www.guerrilla-games.com/read/practical-occlusion-culling-in-killzone-3
                  https://www.youtube.com/watch?v=m0AQBWAbjpo
                  file:///D:/softWare/Kanzi/Documentation/zh-cn/Content/Best%20practices/Measuring%20performance%20of%20your%20application.htm
      浮点数精度：
            根据实际渲染要求，按照最低标准限制每一个浮点数的精度。
      减少纹理采样次数：
            通过纹理划分(例如2*2，3*3，4*4)减少纹理采样次数。不采用UV重新排布以减少采样次数的原因：1 ：重新排布更耗时（3维软件中操作的时间，以及着色器中之前做好的纹理遮罩需要重新映射）2:北美输入的UV排布已经没有很多的面积浪费，基本是最优排布了。
      算法时间复杂度优化：
            利用renderDoc在PC环境测算每帧的以及渲染的每个步骤（从硬盘加载-矩阵转换-深度测试-顶点-片元-渲染管线-光栅化-后处理）的时间复杂度，我会针对时间复杂度高的部件，排查出相应的算法，以及渲染管线的渲染步骤，用“便宜”的方式取代“贵”的方式。
      减少渲染像素
            我会减少光栅化后渲染的像素数量（如2048/2倍=1024）同样的思路或者采用离屏渲染的手段，这个我们测试过，一定是可以把对应机型的帧率跑满的（但这得看客户对锯齿的包容度）。
      减少batchCount
            我会利用顶点色区分部件的手段，合并渲染批次，但保留目前的渲染效果，这个方法对整个渲染来说相当于重构是最伤经动骨，但也是最有效的可以明显减少batch count的（这个方法的风险点在于：第一：OpenGLES的着色器代码字数限制，第二：耗时会比较长）。
      减少循环次数：
            1.把着色器中片元的代码往顶点迁移，减少循环次数，从而降低时间复杂度，弊端：硬件环境下可能会出现因为循环次数过少，导致渲染精度或者效果不正确。
            2.从3D软件中对模型减面，降低顶点的时间，空间复杂度（微量）。
      算法+重构渲染管线/渲染方式：
            类似于unity和unreal2022年推出的nanite算法，用算法进行动态曲面细分，动态纹理烘培，目标是1个batch count（这个实现周期会非常长，但十分有效）。

特殊操作：
      toneMap：（减少过曝）
            https://zhuanlan.zhihu.com/p/21983679
      模糊算法、景深：（变焦）
            https://zhuanlan.zhihu.com/p/125744132
      PS操作：
            https://zhuanlan.zhihu.com/p/108820522
ref:
      FORTICHE 法国
      https://paroj.github.io/gltut/
      https://github.com/RayTracing/raytracing.github.io
      https://www.pbr-book.org/